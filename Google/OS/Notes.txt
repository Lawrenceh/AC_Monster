* What happens when we turn on computer?

The BIOS chip tells it to look in a fixed place, usually on the lowest-numbered hard disk (the boot disk) for a special program called a boot loader (under Linux the boot loader is called Grub or LILO). The boot loader is pulled into memory and started. The boot loaders job is to start the real operating system.

0. BIOS starts up.
1. POST (Power On Self Test) The Power On Self Test happens at the very beginning.
2. The Master Boot Record (MBR), trying to find OS on the hard drive.
3. init, the last step of the kernel boot sequence, which decides the initial state of the OS (system halt, single user mode, reboot, etc.)

* In-Memory Layout of a Program

1. Each process in a multitasking OS runs in its own memory sandbox. This is the virtual address space, which in case of a 32-bit system is always a 4GB block of memory addresses.
2. These virtual addresses (generated by the CPU) are then mapped to real, physical memory addresses by page tables.
3. Since the OS kernel is a process itself, it has a dedicated portion of the virtual address space.


https://gabrieletolomei.files.wordpress.com/2013/10/program_in_memory2.png

higher addr | OS kernel space (reserved)
            | --------------------------
            | Stack 
            |
            |
            | Heap
            | BBS (uninited static variables, filled with zeros)
            | Data (static variables explicitly inited)
            | Text (executable instructions of a program)


* Copy-on-write

Copy-on-write finds its main use in sharing the virtual memory of operating system processes, in the implementation of the fork system call. Typically, the process does not modify any memory and immediately executes a new process, replacing the address space entirely. Thus, it would be wasteful to copy all of the process's memory during a fork, and instead the copy-on-write technique is used. It can be implemented efficiently using the page table by marking certain pages of memory as read-only and keeping a count of the number of references to the page. When data is written to these pages, the kernel intercepts the write attempt and allocates a new physical page, initialized with the copy-on-write data, although the allocation can be skipped if there is only one reference. The kernel then updates the page table with the new (writable) page, decrements the number of references, and performs the write. 


* Context switch

1. Multitasking
2. Interrupt handling
3. user and kernel mode switching 


* Critical Section

acquireLock();
Process Critical Section
releaseLock();


* Inter Process Communication

1. Signal
e.g. Ctrl-C, Exceptions like division by zero or segfault will generate signals SIGINT, SIGFPE, SIGSEGV (v for violation)

2. Socket
e.g. Create a socket binded to a server address, and use netcat to mock client sending messages to the server

3. Message Queue
e.g. RabbitMQ

4. Pipe
e.g. named pipe in C++, created by mkfifo()

5. Shared Memory
6. File


* Synchronization

1. Semaphore
2. Spinlock
3. Barrier
4. Mutual exclusion

* Mutex vs Semaphore

Strictly speaking, a mutex is a locking mechanism used to synchronize access to a resource. Only one task (can be a thread or process based on OS abstraction) can acquire the mutex. It means there will be ownership associated with mutex, and only the owner can release the lock (mutex).

Semaphore is signaling mechanism (I am done, you can carry on, kind of signal). For example, if you are listening songs (assume it as one task) on your mobile and at the same time your friend called you, an interrupt will be triggered upon which an interrupt service routine (ISR) will signal the call processing task to wakeup.

The mutex is similar to the principles of the binary semaphore with one significant difference: the principle of ownership. Ownership is the simple concept that when a task locks (acquires) a mutex only it can unlock (release) it. If a task tries to unlock a mutex it hasnt locked (thus doesnt own) then an error condition is encountered and, most importantly, the mutex is not unlocked. If the mutual exclusion object doesnt have ownership then, irrelevant of what it is called, it is not a mutex.


* Virtual memory

Virtual Memory is a memory management technique that is implemented using both hardware (MMU) and software (operating system). It abstracts from the real memory available on a system by introducing the concept of virtual address space, which allows each process thinking of physical memory as a contiguous address space (or collection of contiguous segments).

The goal of virtual memory is to map virtual memory addresses generated by an executing program into physical addresses in computer memory. This concerns two main aspects: address translation (from virtual to physical) and virtual address spaces management. The former is implemented on the CPU chip by a specific hardware element called Memory Management Unit or MMU. The latter is instead provided by the operating system.

The primary benefits of virtual memory include:
1. freeing applications (and programmers) from having to manage a shared memory space
2. increasing security due to memory isolation
3. being able to conceptually use more memory than might be physically available, using paging

Pages are typically 4KB in size.

Translation process:
1. MMU first searches for it in the TLB cache
2. if it fails, does a page walk (search on the whole page table)
3. if it succeeds, update TLB cache and return; if not, we get 
    - segmentation fault
    - or, page fault
4. the page supervisor accesses the disk, re-stores in main memory the page corresponding to the virtual address that originated the page fault. Then it updates TLB.

See more: 
- https://www.geeksforgeeks.org/wp-content/uploads/gq/2016/01/size.png
- https://www.geeksforgeeks.org/wp-content/uploads/gq/2016/01/Size1.png


* Thrashing

Thrashing occurs when processes on system require more memory than it has. If processes do not have enough pages, the page fault rate is very high.


* Stack frame

A call stack is composed of stack frames.

At function return, the stack pointer is instead restored to the frame pointer, the value of the stack pointer just before the function was called.


